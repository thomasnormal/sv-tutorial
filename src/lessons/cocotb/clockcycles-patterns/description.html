<p>
  This lesson focuses on cycle-accurate test writing. Instead of waiting fixed nanoseconds,
  the test drives a pulse pattern and checks state on every clock edge.
</p>
<p>
  Open <code>pulse_counter.sv</code> and implement a 4-bit counter that increments only when
  <code>pulse</code> is high. Reset is synchronous.
</p>
<p>
  The test (<code>test_pulse_counter.py</code>) uses:
</p>
<ul>
  <li><code>Clock</code> to run a free-running clock in the background</li>
  <li><code><dfn data-card="ClockCycles(clk, n) is a cocotb trigger that suspends the coroutine for exactly n rising edges of the given clock signal. It's equivalent to calling await RisingEdge(clk) in a loop n times, but more compact and readable. Use it for sequencing multi-cycle operations: reset for 5 cycles, then apply stimulus.">ClockCycles</dfn></code> for compact reset sequencing</li>
  <li><code>RisingEdge</code> in a loop to check expected state each cycle</li>
</ul>
<p>
  This is the same style used in larger cocotb environments: drive, await edge, assert.
</p>
