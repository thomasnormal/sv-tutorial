<p>
  <a href="https://docs.cocotb.org" target="_blank">cocotb</a> (<dfn data-card="Coroutine-based Co-simulation Testbench — a Python framework that lets you write simulation testbenches using Python async/await coroutines instead of SystemVerilog. The simulator (e.g. Icarus Verilog, Verilator) still runs the RTL; cocotb drives signals and reads results through a VPI/VHPI bridge. You get the full Python ecosystem — NumPy, matplotlib, pandas — for processing waveform data and generating stimulus.">Coroutine-based Co-simulation Testbench</dfn>)
  is an alternative to UVM: write your testbench in Python rather than SystemVerilog. The simulator
  runs your DUT exactly as before; Python drives signals and checks outputs through an <code>async</code> coroutine.
</p>
<p>
  A test is any <code>async</code> function decorated with <code>@cocotb.test()</code>. The <code>dut</code>
  argument gives you handles to every port — assign <code>.value</code> to drive, read <code>.value</code>
  to observe. <code>await Timer(2, units="ns")</code> suspends the coroutine until combinational logic
  settles — the Python equivalent of <code>#2;</code> in SystemVerilog.
</p>
<p>
  Open <code>adder.sv</code>. The Python testbench already drives four input combinations and checks
  the result. Add the missing <code>assign</code> statement to make all checks pass.
</p>
