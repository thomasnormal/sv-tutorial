              <p>The SRAM's read path uses a multiplexer like this to select the right word from the memory array based on <code>addr</code>:</p>
              <svg width="300" height="150" viewBox="0 0 300 150" xmlns="http://www.w3.org/2000/svg" style="display:block;max-width:100%;font-family:'IBM Plex Mono',monospace;font-size:13px;margin:10px auto">
                <defs><marker id="mux-a" markerWidth="7" markerHeight="6" refX="7" refY="3" orient="auto"><path d="M0,0 L7,3 L0,6 Z" fill="#1e2a2c"/></marker></defs>
                <!-- MUX trapezoid body -->
                <polygon points="130,15 190,30 190,110 130,125" fill="#e6f5f5" stroke="#0d6f72" stroke-width="2"/>
                <text x="160" y="68" text-anchor="middle" fill="#0d6f72" font-size="13" font-weight="bold">4:1</text>
                <text x="160" y="84" text-anchor="middle" fill="#0d6f72" font-size="13">MUX</text>
                <!-- Input lines: a, b, c, d -->
                <line x1="60" y1="35" x2="128" y2="35" stroke="#1e2a2c" stroke-width="1.5" marker-end="url(#mux-a)"/>
                <text x="54" y="39" text-anchor="end" fill="#1e2a2c">a</text>
                <line x1="60" y1="57" x2="128" y2="57" stroke="#1e2a2c" stroke-width="1.5" marker-end="url(#mux-a)"/>
                <text x="54" y="61" text-anchor="end" fill="#1e2a2c">b</text>
                <line x1="60" y1="82" x2="128" y2="82" stroke="#1e2a2c" stroke-width="1.5" marker-end="url(#mux-a)"/>
                <text x="54" y="86" text-anchor="end" fill="#1e2a2c">c</text>
                <line x1="60" y1="104" x2="128" y2="104" stroke="#1e2a2c" stroke-width="1.5" marker-end="url(#mux-a)"/>
                <text x="54" y="108" text-anchor="end" fill="#1e2a2c">d</text>
                <!-- Select line (bottom) -->
                <line x1="160" y1="145" x2="160" y2="128" stroke="#cc5f2d" stroke-width="1.5" marker-end="url(#mux-a)"/>
                <text x="160" y="149" text-anchor="middle" fill="#cc5f2d">sel</text>
                <!-- Output line -->
                <line x1="192" y1="70" x2="240" y2="70" stroke="#1e2a2c" stroke-width="1.5" marker-end="url(#mux-a)"/>
                <text x="244" y="74" fill="#1e2a2c">y</text>
              </svg>
              <p>An <code><dfn data-card="always_comb is the SystemVerilog construct for combinational logic. The simulator automatically infers the sensitivity list — it re-evaluates the block whenever any signal read inside it changes. Unlike always @(*), always_comb also fires once at time zero and warns if you accidentally create latches by not assigning every output on every path.">always_comb</dfn></code> block models combinational logic. It re-evaluates automatically whenever any of its inputs change — no sensitivity list needed.</p>
              <p>Inside it you can use procedural statements like <code>if</code> and <code>case</code>. The <code>case</code> statement is often cleaner than a chain of <code>if-else</code> for multi-way selection. Each branch uses the pattern:</p>
              <pre>value: output = input;</pre>
              <p>Open <code>mux.sv</code> and fill in all four branches of the <code>case (sel)</code> block.</p>
              <h2>Testbench</h2>
              <p>Each input is initialized to a distinct hex constant — <code>AA</code>, <code>BB</code>, <code>CC</code>, <code>DD</code> — so it is immediately obvious which input was selected. The testbench steps <code>sel</code> through all four values and checks the output:</p>
              <pre>sel=0; #1 $display("sel=0 → y=%0h (expect aa)", y);</pre>
              <p>Because <code>mux4</code> is purely combinational, <code>y</code> updates without a clock edge. The <code>#1</code> delay simply lets the combinational logic settle before reading the result.</p>
