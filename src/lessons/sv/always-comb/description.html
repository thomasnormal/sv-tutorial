<p>
Sometimes you need more complicated dependencies between signals than just a simple assignment.
For example, a
<dfn data-card="TODO">multiplexer</dfn>
takes four inputs and selects one of them to pass through to the output based on a select signal:
<svg width="300" height="150" viewBox="0 0 300 150" xmlns="http://www.w3.org/2000/svg" style="display:block;max-width:100%;font-family:'IBM Plex Mono',monospace;font-size:13px;margin:10px auto">
   <defs><marker id="mux-a" markerWidth="7" markerHeight="6" refX="7" refY="3" orient="auto"><path d="M0,0 L7,3 L0,6 Z" fill="#1e2a2c"/></marker></defs>
   <!-- MUX trapezoid body -->
   <polygon points="130,15 190,30 190,110 130,125" fill="#e6f5f5" stroke="#0d6f72" stroke-width="2"/>
   <text x="160" y="68" text-anchor="middle" fill="#0d6f72" font-size="13" font-weight="bold">4:1</text>
   <text x="160" y="84" text-anchor="middle" fill="#0d6f72" font-size="13">MUX</text>
   <!-- Input lines: a, b, c, d -->
   <line x1="60" y1="35" x2="128" y2="35" stroke="#1e2a2c" stroke-width="1.5" marker-end="url(#mux-a)"/>
   <text x="54" y="39" text-anchor="end" fill="#1e2a2c">a</text>
   <line x1="60" y1="57" x2="128" y2="57" stroke="#1e2a2c" stroke-width="1.5" marker-end="url(#mux-a)"/>
   <text x="54" y="61" text-anchor="end" fill="#1e2a2c">b</text>
   <line x1="60" y1="82" x2="128" y2="82" stroke="#1e2a2c" stroke-width="1.5" marker-end="url(#mux-a)"/>
   <text x="54" y="86" text-anchor="end" fill="#1e2a2c">c</text>
   <line x1="60" y1="104" x2="128" y2="104" stroke="#1e2a2c" stroke-width="1.5" marker-end="url(#mux-a)"/>
   <text x="54" y="108" text-anchor="end" fill="#1e2a2c">d</text>
   <!-- Select line (bottom) -->
   <line x1="160" y1="135" x2="160" y2="120" stroke="#cc5f2d" stroke-width="1.5" marker-end="url(#mux-a)"/>
   <text x="160" y="149" text-anchor="middle" fill="#cc5f2d">sel</text>
   <!-- Output line -->
   <line x1="192" y1="70" x2="240" y2="70" stroke="#1e2a2c" stroke-width="1.5" marker-end="url(#mux-a)"/>
   <text x="244" y="74" fill="#1e2a2c">y</text>
</svg>
<p>
Later we'll use this for the SRAM to select the right word from the memory array based on the address.
</p>
<p><code>always_comb begin ... end</code>
is a block that evaluates whenever any of the signals read inside it change.
Inside it you can use
<dfn data-card="TODO: What other procedural statements are there? What is the definition of a procedural statement?">
   procedural statements</dfn> like
<pre>
if (sel == 0) y = a;
else if (sel == 1) y = b;
else if (sel == 2) y = c;
else y = d;
</pre>
or you can use a <code>case</code> statement:
<pre>
case (sel)
   0: y = a;
   1: y = b;
   2: y = c;
   3: y = d;
endcase
</pre>
<p>
Pick one of the patterns
and implement the missing code in <code>mux.sv</code>.
</p>
<blockquote><p>Another interesting combinatorial block is
  <code><dfn data-card="casez is a case variant that treats ? (and z) bits in the case expression or branch values as wildcards — they match either 0 or 1. This makes it perfect for priority encoders where you only care about the position of the highest set bit. casex treats x as a wildcard too, but is avoided in synthesis because X-propagation becomes unpredictable.">casez</dfn></code>
  which allows you to put <code>?</code> in the case expression or branch values to match either 0 or 1.
  For example
<pre>casez (req)
  3'b1??: y = a;
  3'b01?: y = b;
  3'b001: y = c;
endcase</pre>
  but we don't need that here.
   </p></blockquote>
<h2>Testbench</h2>
<p>Each input is initialized to a distinct hex constant — <code>AA</code>, <code>BB</code>, <code>CC</code>, <code>DD</code> — so it is immediately obvious which input was selected. The testbench steps <code>sel</code> through all four values and checks the output:</p>
<pre>sel=0; #1 $display("sel=0 → y=%0h (expect aa)", y);</pre>
<p>Because <code>mux4</code> is purely combinational
(it has no flip-flops or latches, just logic gates),
<code>y</code> updates without a clock edge. The <code>#1</code>
<dfn
data-card="
a delay like #1 is a **procedural time delay** that pauses execution of the current statement by 1 time unit before it runs. (One can define a time unit to be e.g., 1ns or 1ps.) Delays can be integers or real numbers (e.g., #0.5) and are commonly used in testbenches to model time progression, schedule signal changes, or create stimulus during simulation.
">
delay
</dfn>
simply lets the combinational logic settle before reading the result.</p>
