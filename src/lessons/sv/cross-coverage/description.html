              <p>Cross coverage finds the combinations we haven't hit. For the SRAM the critical question is not just "did we hit both address halves?" and "did we do both reads and writes?" — it's "did we write to the <em>upper</em> half as well as the lower half?"</p>
              <p>Two coverpoints can each report 100% while an entire class of interactions is untested. If all writes happened to land on low addresses and all reads on high addresses, both <code>cp_addr</code> and <code>cp_we</code> reach 100% — but the cross reveals the gap.</p>
              <p><strong>Cross coverage</strong> tracks combinations. Crossing two coverpoints with <em>m</em> and <em>n</em> bins produces <em>m × n</em> cross-bins. For the SRAM that is 2 × 2 = 4 bins:</p>
              <pre>addr_x_we: cross cp_addr, cp_we;</pre>
              <p>Open <code>cov_cross.sv</code>. The two coverpoints from the previous lesson are already defined. Add the <code>addr_x_we</code> cross definition inside the covergroup. Run to see whether 64 random cycles hit all four address-half × read/write combinations.</p>
              <blockquote><p>This is the central lesson of cross coverage: perfect scores on individual coverpoints can hide large gaps. Cross coverage is especially valuable for address region × operation type, opcode × privilege level, or any pair of orthogonal protocol dimensions.</p></blockquote>
