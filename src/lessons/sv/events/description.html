<p>
Recall that <code>initial</code> blocks start at t=0.
This happens even if there are multiple <code>initial</code> blocks in the same module, and even if they are in different modules. They all start at the same time, and run concurrently.
This is a powerful feature: it lets you write separate processes that run in parallel, without needing to manually interleave their code.
But it also means you need to coordinate them, so they don't step on each other's toes.
</p>
<p>
For example, an SRAM testbench may want to write some values into memory, and then read them back.
We can do this with two <code>initial</code> blocks, but we need to make sure the reader waits until the writer is done.
</p>
<p>
We can coordinate concurrent processes using <dfn data-card="Events are similar to constructions in many other programming languages. Such as threading.Event in Python, std::condition_variable in C++, sync.Cond in Go, and so on.
The main gotcha is that System Verilog events are not stateful (latching).
If you wait for an event that has already been posted, you will wait forever.">events</dfn>.
An event is a named synchronization point that processes can wait for or post.
The basic operations on events are: </p>
<ul>
   <li><code>event write_done</code>: declare a named event</li>
   <li><code>-&gt; write_done</code>: "post" the event — wakes every process</li>
   <li><code>@(write_done)</code>: wait for the event — suspends until posted</li>
</ul>
<p>
<blockquote><p>Note: You could also just write <code>@ write_done</code>, but using brackets around the event is a universal convention</p></blockquote>

<p>The post is instantaneous: every process suspended at <code>@(write_done)</code> resumes in the same simulation time step. Events carry no data and cannot be synthesised — they live only in testbenches and simulation models.</p>

<h2>A two-event pipeline</h2>
<p><code>event_sync.sv</code> chains writer, reader, and checker using two events:</p>
<!-- Three-process timing diagram -->
<svg width="430" height="120" viewBox="0 0 430 120" xmlns="http://www.w3.org/2000/svg" style="display:block;max-width:100%;font-family:'IBM Plex Mono',monospace;font-size:12px;margin:10px auto">
  <rect width="430" height="120" rx="4" fill="#fffdf7"/>
  <line x1="78" y1="108" x2="425" y2="108" stroke="#d5cbb2" stroke-width="1"/>
  <text x="78"  y="118" text-anchor="middle" fill="#8a9da2" font-size="11">t=0</text>
  <text x="218" y="118" text-anchor="middle" fill="#8a9da2" font-size="11">t=10</text>
  <!-- write_done vertical -->
  <line x1="218" y1="6" x2="218" y2="100" stroke="#0d6f72" stroke-width="1.5" stroke-dasharray="4,3"/>
  <text x="221" y="14" fill="#0d6f72" font-size="10">→ write_done</text>
  <!-- read_done vertical -->
  <line x1="328" y1="18" x2="328" y2="100" stroke="#0d6f72" stroke-width="1.5" stroke-dasharray="4,3" opacity="0.7"/>
  <text x="331" y="28" fill="#0d6f72" font-size="10" opacity="0.85">→ read_done</text>
  <!-- writer row -->
  <text x="72" y="35" text-anchor="end" fill="#586469" font-size="11">writer</text>
  <line x1="78" y1="32" x2="196" y2="32" stroke="#cc5f2d" stroke-width="2"/>
  <rect x="197" y="23" width="40" height="16" rx="2" fill="#fef3e8" stroke="#cc5f2d" stroke-width="1"/>
  <text x="217" y="34" text-anchor="middle" fill="#9a3a15" font-size="10">write</text>
  <line x1="237" y1="32" x2="425" y2="32" stroke="#d5cbb2" stroke-width="1.5" stroke-dasharray="3,3"/>
  <!-- reader row -->
  <text x="72" y="67" text-anchor="end" fill="#586469" font-size="11">reader</text>
  <line x1="78" y1="64" x2="218" y2="64" stroke="#d5cbb2" stroke-width="2" stroke-dasharray="5,3"/>
  <text x="148" y="57" text-anchor="middle" fill="#8a9da2" font-size="10">suspended</text>
  <line x1="218" y1="64" x2="306" y2="64" stroke="#3d9fa3" stroke-width="2"/>
  <rect x="307" y="55" width="40" height="16" rx="2" fill="#e6f5f5" stroke="#0d6f72" stroke-width="1"/>
  <text x="327" y="66" text-anchor="middle" fill="#0a5558" font-size="10">check</text>
  <line x1="347" y1="64" x2="425" y2="64" stroke="#d5cbb2" stroke-width="1.5" stroke-dasharray="3,3"/>
  <!-- checker row -->
  <text x="72" y="99" text-anchor="end" fill="#586469" font-size="11">checker</text>
  <line x1="78" y1="96" x2="328" y2="96" stroke="#d5cbb2" stroke-width="2" stroke-dasharray="5,3"/>
  <text x="203" y="89" text-anchor="middle" fill="#8a9da2" font-size="10">suspended</text>
  <line x1="328" y1="96" x2="378" y2="96" stroke="#3d9fa3" stroke-width="2"/>
  <rect x="379" y="87" width="42" height="16" rx="2" fill="#e6f5f5" stroke="#0d6f72" stroke-width="1"/>
  <text x="400" y="98" text-anchor="middle" fill="#0a5558" font-size="10">report</text>
</svg>

<p>Add the four TODO lines — one <code>-&gt;</code> and one <code>@</code> per handshake. Without them, the reader and checker start at t=0, read uninitialised <code>x</code> values, and <code>PASS</code> never prints.</p>

<blockquote><p>Warning: If you add <code>@(write_done)</code> but forget <code>-> write_done</code>, the reader waits forever and the simulation never finishes. Each handshake requires both sides: a sender and at least one receiver.</p></blockquote>
<p>
Hint: You can follow the events status in the simulator waveform viewer, just like any other signal.
</p>

<h2>Built-in vs named events</h2>
<p>
A very important built-in event is <code>posedge clk</code>.
This even is generated automatically by the simulator whenever the signal <code>clk</code> transitions from 0 to 1.
You don't post it yourself, but you can wait for it with <code>@(posedge clk)</code>.
<p>In the next lesson, <code>always_ff @(posedge clk)</code> uses exactly this: the block suspends at the rising-edge event and latches new values into the flip-flop array. Every register in our SRAM waits for that one recurring event.</p>
