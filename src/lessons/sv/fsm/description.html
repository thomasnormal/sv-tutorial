              <p>A <strong><dfn data-card="A Moore FSM (Finite State Machine) is one where the outputs depend only on the current state, not on the current inputs. This makes outputs glitch-free and registered. Contrast with a Mealy FSM where outputs depend on both state and inputs (faster response, one cycle earlier, but outputs can glitch mid-cycle). Moore FSMs are preferred in synchronous RTL because output timing is predictable.">Moore FSM</dfn></strong> separates state memory from output computation into two <code>always</code> blocks. The <strong>memory access controller</strong> decides when and how the SRAM gets written or read:</p>
              <ul>
                <li><strong>IDLE</strong> — waiting for a command; assert <code>ready=1</code>. On the next cycle, transition to WRITING if <code>cmd_valid &amp;&amp; cmd_we</code>, to READING if <code>cmd_valid &amp;&amp; !cmd_we</code>, otherwise stay in IDLE.</li>
                <li><strong>READING</strong> — assert <code>sram_we=0</code> and return to IDLE next cycle</li>
                <li><strong>WRITING</strong> — assert <code>sram_we=1</code> and return to IDLE next cycle</li>
              </ul>
              <p>Open <code>mem_ctrl.sv</code>. The two-always skeleton and default assignments are already set up. Fill in the <code>case</code> branches inside <code>always_comb</code>: the transition conditions in <code>IDLE</code>, and the output + transition for <code>READING</code> and <code>WRITING</code>.</p>
              <blockquote><p>Keep outputs in the <code>always_comb</code> block, never in the <code>always_ff</code> block — Moore outputs are a function of state only, not of the next cycle's inputs.</p></blockquote>
              <h2>Testbench</h2>
              <p>The testbench cycles through all three states — idle, write command, read command — and checks that <code>sram_we</code> and <code>ready</code> assert at the right times.</p>
