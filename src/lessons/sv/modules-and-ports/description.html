<p>Modules communicate through <strong>ports</strong>. Each port has a direction (<code>input</code>, <code>output</code>, or <code>inout</code>) and a type.</p>
<p>The most common type is <code><dfn data-card="logic is SystemVerilog's universal net/variable type. Unlike Verilog's wire/reg distinction, logic works everywhere. It has four states: 0 (logic low), 1 (logic high), X (unknown — driven to conflicting values or uninitialized), and Z (high-impedance — not driven, floating). X propagation catches design bugs: if any input is X, the output is usually X too.">logic</dfn></code> — a 4-state value that can be <code>0</code>, <code>1</code>, <code>X</code> (unknown), or <code>Z</code> (high-impedance). Vectors use a range: <code>logic [7:0]</code> is 8 bits wide.</p>
<p>Combinational logic is driven by a continuous <code>assign</code> statement — it updates the output wire instantly whenever any input changes. Open <code>adder.sv</code> and add the missing <code>assign</code> line that produces <code>sum</code> from <code>a</code> and <code>b</code>.</p>
<h2>Testbench</h2>
<p>Every design needs a <strong><dfn data-card="A testbench is a SystemVerilog module written purely for simulation — it is never synthesized into hardware. It instantiates the design under test (DUT), drives its inputs with stimulus, and checks that the outputs match expected values. Testbenches can range from a simple initial block to a full UVM environment.">testbench</dfn></strong> (<code>tb.sv</code>) — a separate module that drives inputs and checks outputs. It is never synthesized; it only runs in simulation.</p>
<p>The testbench <em>instantiates</em> the <dfn data-card="DUT (Design Under Test) — the module being verified. In simulation, the testbench wraps the DUT, connecting its ports to stimulus generators and output checkers. In formal verification, the tool itself exercises all possible inputs.">design under test</dfn> (the <code>adder</code>) and connects its ports by name:</p>
<pre>adder dut(.a(a), .b(b), .sum(result));</pre>
<p>An <code>initial</code> block runs once at time zero. Here it sets <code>a = 10</code> and <code>b = 32</code>, then after a 1-unit delay prints the result with <code>$display</code>.</p>
<p>After running the code, you should see the correct sum of <code>42</code> (<code>0x2a</code>) in the Waves tab:</p>
<p><img src="waves.png" alt="Adder waveform" style="max-width:100%; border-radius:6px;"></p>
<p>The SRAM we'll build uses exactly these port conventions — <code>input we</code>, <code>input addr</code>, <code>input wdata</code>, <code>output rdata</code> — just with a more interesting body that holds data in a flip-flop array rather than computing it combinationally.</p>
