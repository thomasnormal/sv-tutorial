<p>An alternative to <code>case</code> is <code><dfn data-card="casez is a case variant that treats ? (and z) bits in the case expression or branch values as wildcards — they match either 0 or 1. This makes it perfect for priority encoders where you only care about the position of the highest set bit. casex treats x as a wildcard too, but is avoided in synthesis because X-propagation becomes unpredictable.">casez</dfn></code> treats <code>?</code> as a don't-care bit, making it ideal for <dfn data-card="A priority encoder converts a one-hot or partially-set input vector into a binary index of the highest-priority asserted bit. When multiple requestors assert simultaneously, the priority encoder grants only the highest-indexed one. Used in arbitration logic, interrupt controllers, and multi-port SRAM write arbitration.">priority logic</dfn> where only the <em>highest-set</em> bit matters.</p>
<p>Open <code>priority_enc.sv</code> and add four <code>casez</code> branches. The highest-index asserted bit in <code>req</code> wins. If no bit is set, output <code>valid = 0</code>. The first branch to match wins, so put the highest-priority pattern first:</p>
<pre>casez (req)
  4'b1???: begin grant = 2'd3; valid = 1'b1; end
  // ... three more branches
endcase</pre>
<blockquote><p>Always-combinational blocks should have a <strong>default assignment</strong> before the <code>casez</code> to avoid unintended latches if no branch matches.</p></blockquote>
<h2>Testbench</h2>
<p>The testbench applies four representative inputs and checks which requester wins, using <code>@(posedge clk)</code> to step one cycle between each test — the same wait-for-event pattern from the events lesson:</p>
<pre>req = 4'b0110; @(posedge clk);
$display("... (expect grant=2)", ...);</pre>
<p>The critical case is <code>4'b0110</code> — bits 1 <em>and</em> 2 are both set, so the encoder must grant bit 2 (the higher index), not bit 1. This confirms that the <code>casez</code> branches are ordered correctly, with the highest-priority pattern first.</p>
<p>Priority encoders arbitrate simultaneous write requests in multi-port SRAMs — when two masters try to write the same address on the same cycle, the priority encoder determines which one wins.</p>
