<p>A <strong><code><dfn data-card="A SystemVerilog checker is a named block (checker...endchecker) that encapsulates assertions. Like a module, it has ports and can be instantiated multiple times — so you can write a handshake_check once and reuse it for every req/ack pair in the design. Unlike a module, a checker is automatically excluded from synthesis, can take clocking events as formal arguments, and can be instantiated inside procedural blocks.">checker</dfn></code></strong> is a named, encapsulated block of assertions that can be instantiated anywhere a module instance is legal — and also inside procedural blocks. Unlike a module, a checker is automatically excluded from synthesis and can take clocking events as formal arguments.</p>
<pre>checker handshake_check(input logic clk, req, ack);
  // ... properties go here ...
endchecker

module top(input logic clk, req1, ack1, req2, ack2);
  // Reuse the same checker for two independent channels
  handshake_check c1(clk, req1, ack1);
  handshake_check c2(clk, req2, ack2);
endmodule</pre>
<p>The WASM tool does not yet lower the <code>checker</code>/<code>endchecker</code> keywords, so this exercise uses a regular <code>module</code> instead — the semantics are identical for verification purposes. Open <code>top.sv</code> and complete the property inside <code>handshake_check</code>.</p>
<blockquote><p>Checkers can also accept <code>sequence</code>, <code>property</code>, and <code>event</code> typed formal arguments, making them fully parameterisable assertion bundles — the SVA equivalent of generic verification IP.</p></blockquote>
