            <p>In simulation you check assertions against a <em>specific</em> sequence of inputs driven by a testbench. Formal verification — specifically <strong>Bounded Model Checking (BMC)</strong> — does something more powerful: it exhaustively explores <em>every possible</em> input sequence up to a given number of clock cycles, looking for any that violates an assertion.</p>
            <p>There is no testbench needed for BMC. The tool treats all inputs as free variables and tries to find a <strong>counterexample</strong>. If it cannot find one within the bound, the property is proved to hold for all inputs up to that depth.</p>
            <p>Open <code>top.sv</code>. A 4-bit counter resets to <code>0</code> when <code>rst</code> is high. Add the assertion that proves this:</p>
            <pre>rst_clears: assert property (
@(posedge clk) rst |=> (cnt == 0));</pre>
            <p>Use <strong>run</strong> to simulate with the testbench (watch the counter count up and reset), then <strong>verify</strong> to have BMC prove the reset property holds for <em>every</em> possible input sequence.</p>
            <blockquote><p>Simulation confirms behaviour on one specific trace. BMC proves (or disproves) a property on all traces up to the bound — a much stronger guarantee.</p></blockquote>
