            <p><strong><dfn data-card="LEC (Logical Equivalence Checking) formally proves that two netlists or RTL descriptions produce identical output for every possible input combination. It is used after synthesis, optimization, and place-and-route to prove the transformations preserved the circuit's behavior. The tool encodes both designs as Boolean formulas and uses a SAT/SMT solver to search for any input that causes them to differ.">Logical Equivalence Checking (LEC)</dfn></strong> proves that two circuit implementations produce identical outputs for every possible input — without running any simulation.</p>
            <p>Open <code>top.sv</code>. It contains two modules:</p>
            <ul>
              <li><code>Spec</code> — the golden reference: a NAND gate <code>~(a &amp; b)</code></li>
              <li><code>Impl</code> — your implementation, currently wrong</li>
            </ul>
            <p>The <code>Impl</code> module has a bug — one of the inversions is missing. By <strong><dfn data-card="De Morgan's laws state that NOT(A AND B) = (NOT A) OR (NOT B), and NOT(A OR B) = (NOT A) AND (NOT B). They're fundamental to boolean algebra and let you rewrite logic in equivalent forms. In circuit design, they explain why a NAND gate followed by inverters equals a NOR gate with inverted inputs — crucial for understanding how logic synthesis produces structurally different but functionally identical circuits.">De Morgan's law</dfn></strong>, <code>~(a &amp; b)</code> is logically equivalent to an OR of the individually inverted inputs. Fix <code>Impl</code> so both circuits are equivalent.</p>
            <p>Click <strong>verify</strong> to run LEC on the buggy code first. The tool encodes both modules as SMT constraints and asks a solver whether any input can make them differ. Because the bug is real, the solver finds one — it reports <strong>sat</strong> and shows how the model was extracted:</p>
            <pre>$ z3 /workspace/out/check.smt2
sat
$ z3 -model /workspace/out/check.smt2 | grep define-fun
  (define-fun b () (_ BitVec 2) #b00)
  (define-fun a () (_ BitVec 2) #b10)
  (define-fun c1_out0 () (_ BitVec 2) #b10)
  (define-fun c2_out0 () (_ BitVec 2) #b00)
# counterexample: b=0 a=1</pre>
            <p>Reading the model output: <code>(define-fun b () (_ BitVec 2) #b00)</code> means <code>b=0</code>, and the next line means <code>a=1</code>. (This is a four-state encoding: <code>#b00</code>=logic 0, <code>#b10</code>=logic 1, <code>#b01</code>=Z, <code>#b11</code>=X.) The <code>c1_out0</code> and <code>c2_out0</code> lines are the output values of each circuit.</p>
            <p>You can verify that <code>a=1, b=0</code> proves the models are different: Spec produces <code>~(1 &amp; 0) = 1</code> while the buggy Impl produces <code>~1 | 0 = 0</code>.</p>
            <p>Fix the bug, then click <strong>verify</strong> again. With no distinguishing input, the solver reports <strong>unsat</strong> — the circuits are equivalent for every possible input.</p>
            <blockquote><p>LEC is essential in chip design: it proves that logic synthesis, optimisation, and place-and-route have not changed the circuit's behaviour.</p></blockquote>
