<p>A <strong>recursive property</strong> refers to itself in its own consequent, creating a self-referential temporal statement that unrolls indefinitely:</p>
<pre>property p_lock_hold;
  @(posedge clk) lock && !unlock |=> p_lock_hold;
endproperty</pre>
<p>This reads: "if <code>lock</code> is high and <code>unlock</code> has not fired, one cycle later the same condition must hold again — forever, until <code>unlock</code> fires." Recursive properties must use <code>|=&gt;</code> (never <code>|-&gt;</code>) to avoid a zero-time loop, and the recursive call must appear as the <em>consequent</em>, never the antecedent.</p>
<p>The WASM tool does not yet support recursive property calls. This exercise uses the equivalent one-step form that BMC can verify directly: if <code>lock</code> is high and <code>unlock</code> has not fired, <code>lock</code> must be high on the next cycle. BMC checks this for every cycle up to its bound — which is equivalent to the recursive version within any finite trace. Open <code>lock_check.sv</code> and complete the property.</p>
<blockquote><p>Full formal tools prove recursive properties by <dfn data-card="Induction in formal verification works like mathematical induction: first prove the base case (the property holds at step 0), then prove the inductive step (if the property holds at step k, it must also hold at step k+1). Together these give an unbounded proof for all time steps, without needing to check every depth explicitly. k-induction strengthens this by using k consecutive steps in the inductive case, allowing proofs for circuits with deeper invariants.">induction</dfn>: they show (a) the property holds at step 0, and (b) if it holds at step k, it holds at step k+1. This gives an unbounded proof without requiring an unbounded bound.</p></blockquote>
